:mod:`hio.core.tcp.serving`
===========================

.. py:module:: hio.core.tcp.serving

.. autoapi-nested-parse::

   hio.core.tcp.serving Module

   Accepter listens and accepts incoming TCP socket connections
   Server is subclass of Acceptor
   Server creates Remoters
   Remoter is accepted incoming socket connection

   ServerTls is subclass of Server
   RemoterTls is subclass of Remoter



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   hio.core.tcp.serving.Acceptor
   hio.core.tcp.serving.Server
   hio.core.tcp.serving.ServerTls
   hio.core.tcp.serving.Remoter
   hio.core.tcp.serving.RemoterTls



Functions
~~~~~~~~~

.. autoapisummary::

   hio.core.tcp.serving.openServer
   hio.core.tcp.serving.initServerContext



.. function:: openServer(cls=None, **kwa)

   Wrapper to create and open Server instances
   When used in with statement block, calls .close() on exit of with block

   :param cls is Class instance of subclass instance:

   Usage:
       with openServer() as server0:
           server0.

       with openServer(cls=ServerTls) as server0:
           server0.


.. class:: Acceptor(ha=None, bs=8096, **kwa)


   Bases: :py:obj:`hio.base.tyming.Tymee`

   Acceptor Base Class for Server.
   Nonblocking TCP Socket Acceptor Class.
   Listen socket for incoming TCP connections

   See tyming.Tymee for inherited attributes, properties, and methods

   .. attribute:: .ha is

      host = "" or "0.0.0.0" means listen on all interfaces

      :type: host,port) duple (two tuple

   .. attribute:: .eha is normalized

      as external facing address for TLS context

      :type: host, port

   .. attribute:: .bs is buffer size

      

   .. attribute:: .ss is server listen socket for incoming accept requests

      

   .. attribute:: .axes is deque of accepte connection duples

      

      :type: ca, cs

   .. attribute:: .opened is boolean, True if listen socket .ss opened. False otherwise

      

   .. method:: actualBufSizes(self)

      Returns duple of the the actual socket send and receive buffer size
      (send, receive)


   .. method:: open(self)

      Opens binds listen socket in non blocking mode.

      if socket not closed properly, binding socket gets error
         socket.error: (48, 'Address already in use')


   .. method:: reopen(self)

      Idempotently opens listen socket


   .. method:: close(self)

      Closes listen socket.


   .. method:: accept(self)

      Accept new connection nonblocking
      Returns duple (cs, ca) of connected socket and connected host address
      Otherwise if no new connection returns (None, None)


   .. method:: serviceAccepts(self)

      Service any accept requests
      Adds to .cxes dict key by ca



.. class:: Server(ha=None, host='', port=56000, timeout=None, wl=None, **kwa)


   Bases: :py:obj:`Acceptor`

   Nonblocking TCP Socket Server Class.
   Listen socket for incoming TCP connections that generates Remoter sockets
   for accepted connections

   See tyming.Tymee for inherited attributes, properties, and methods

   Inherited Attributes:
       .ha is (host,port) duple (two tuple)
              host = "" or "0.0.0.0" means listen on all interfaces
       .eha is normalized (host, port) duple for incoming TLS connections
               as external facing address for TLS context
       .bs is buffer size
       .ss is server listen socket for incoming accept requests
       .axes is deque of accepte connection duples (ca, cs)
       .opened is boolean, True if listen socket .ss opened. False otherwise

   .. attribute:: .timeout is timeout in seconds for connection refresh

      

   .. attribute:: .wl is WireLog instance if any

      

   .. attribute:: .ixes is dict of incoming connections indexed by remote

      

      :type: host, port

   .. attribute:: Timeout
      :annotation: = 1.0

      

   .. method:: wind(self, tymth)

      Inject new tymist.tymth as new ._tymth. Changes tymist.tyme base.
      Updates winds .tymer .tymth


   .. method:: serviceAxes(self)

      Service axes

      For each newly accepted connection in .axes create Remoter
      and add to .ixes keyed by ca


   .. method:: serviceConnects(self)

      Service connects is method name to be used


   .. method:: shutdownIx(self, ca, how=socket.SHUT_RDWR)

      Shutdown remoter given by connection address ca


   .. method:: shutdownSendIx(self, ca)

      Shutdown send on remoter given by connection address ca


   .. method:: shutdownReceiveIx(self, ca)

      Shutdown send on remoter given by connection address ca


   .. method:: closeIx(self, ca)

      Shutdown and close remoter given by connection address ca


   .. method:: closeAllIx(self)

      Shutdown and close all remoter connections


   .. method:: close(self)

      Close all sockets


   .. method:: removeIx(self, ca, close=True)

      Remove remoter given by connection address ca


   .. method:: serviceReceivesIx(self, ca)

      Service receives for remoter by connection address ca


   .. method:: serviceReceivesAllIx(self)

      Service receives for all remoters in .ixes


   .. method:: transmitIx(self, data, ca)

      Queue data onto .txbs for remoter given by connection address ca


   .. method:: serviceSendsAllIx(self)

      Service transmits for all remoters in .ixes


   .. method:: service(self)

      Service connects and service receives and sends for all ix.



.. function:: initServerContext(context=None, version=None, certify=None, keypath=None, certpath=None, cafilepath=None)

   Initialize and return context for TLS Server
   IF context is None THEN create a context

   IF version is None THEN create context using ssl library default
   ELSE create context with version

   If certify is not None then use certify value provided Otherwise use default

   context = context object for tls/ssl If None use default
   version = ssl protocol version If None use default
   certify = cert requirement If None use default
             ssl.CERT_NONE = 0
             ssl.CERT_OPTIONAL = 1
             ssl.CERT_REQUIRED = 2
   keypath = pathname of local server side PKI private key file path
             If given apply to context
   certpath = pathname of local server side PKI public cert file path
             If given apply to context
   cafilepath = Cert Authority file path to use to verify client cert
             If given apply to context


.. class:: ServerTls(context=None, version=None, certify=None, keypath=None, certpath=None, cafilepath=None, **kwa)


   Bases: :py:obj:`Server`

   Server with Nonblocking TLS/SSL support
   Nonblocking TCP Socket Server Class.
   Listen socket for incoming TCP connections
   RemoterTLS sockets for accepted connections

   See tyming.Tymee for inherited attributes, properties, and methods

   Inherited Attributes:
       .ha is (host,port) duple (two tuple)
              host = "" or "0.0.0.0" means listen on all interfaces
       .eha is normalized (host, port) duple for incoming TLS connections
               as external facing address for TLS context
       .bs is buffer size
       .ss is server listen socket for incoming accept requests
       .axes is deque of accepte connection duples (ca, cs)
       .opened is boolean, True if listen socket .ss opened. False otherwise
       .timeout is timeout in seconds for connection refresh
       .wl is WireLog instance if any
       .ixes is dict of incoming connections indexed by remote (host, port) duple

   .. attribute:: .context is TLS context instance

      

   .. attribute:: .version is TLS version

      

   .. attribute:: .certify is boolean, True to client certify, False otherwise

      

   .. attribute:: .keypath is path to key file

      

   .. attribute:: .certpath is path to cert file

      

   .. attribute:: .cafilepath is path to ca file

      

   .. method:: serviceAxes(self)

      Service accepteds

      For each new accepted connection create RemoterTLS and add to .cxes
      Not Handshaked


   .. method:: serviceCxes(self)

      Service handshakes for every remoter in .cxes
      If successful move to .ixes


   .. method:: serviceConnects(self)

      Service accept and handshake attempts
      If not already accepted and handshaked  Then
           make nonblocking attempt
      For each successful handshaked add to .ixes
      Returns handshakeds



.. class:: Remoter(ha, ca, cs, timeout=None, refreshable=True, bs=8096, wl=None, **kwa)


   Bases: :py:obj:`hio.base.tyming.Tymee`

   Class to service an incoming nonblocking TCP connection from a remote client.
   Should only be used from Acceptor subclass

   .. attribute:: Timeout
      :annotation: = 0.0

      

   .. method:: wind(self, tymth)

      Inject new tymist.tymth as new ._tymth. Changes tymist.tyme base.
      Updates winds .tymer .tymth


   .. method:: shutdown(self, how=socket.SHUT_RDWR)

      Shutdown connected socket .cs


   .. method:: shutdownSend(self)

      Shutdown send on connected socket .cs


   .. method:: shutdownReceive(self)

      Shutdown receive on connected socket .cs


   .. method:: close(self)

      Shutdown and close connected socket .cs


   .. method:: refresh(self)

      Restart tymer


   .. method:: receive(self)

      Perform non blocking receive on connected socket .cs

      If no data then returns None
      If connection closed then returns ''
      Otherwise returns data

      data is string in python2 and bytes in python3


   .. method:: serviceReceives(self)

      Service receives until no more


   .. method:: serviceReceiveOnce(self)

      Retrieve from server only one reception


   .. method:: clearRxbs(self)

      Clear .rxbs


   .. method:: send(self, data)

      Perform non blocking send on connected socket .cs.
      Return number of bytes sent

      data is string in python2 and bytes in python3


   .. method:: tx(self, data)

      Queue data onto .txbs


   .. method:: serviceSends(self)

      Service transmits
      For each tx if all bytes sent then keep sending until partial send
      or no more to send
      If partial send reattach and return



.. class:: RemoterTls(context=None, version=None, certify=None, keypath=None, certpath=None, cafilepath=None, **kwa)


   Bases: :py:obj:`Remoter`

   Class to service an incoming nonblocking TCP/TLS connection from a remote client.
   Should only be used from Acceptor subclass
   Provides nonblocking TLS/SSL support

   .. method:: close(self)

      Shutdown and close connected socket .cs


   .. method:: wrap(self)

      Wrap socket .cs in ssl context


   .. method:: handshake(self)

      Attempt nonblocking ssl handshake to .ha
      Returns True if successful
      Returns False if not so try again later


   .. method:: serviceHandshake(self)

      Service connection and handshake attempt
      If not already accepted and handshaked  Then
           make nonblocking attempt
      Returns .handshaked


   .. method:: receive(self)

      Perform non blocking receive on connected socket .cs

      If no data then returns None
      If connection closed then returns ''
      Otherwise returns data

      data is string in python2 and bytes in python3


   .. method:: send(self, data)

      Perform non blocking send on connected socket .cs.
      Return number of bytes sent

      data is string in python2 and bytes in python3



